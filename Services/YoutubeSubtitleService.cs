using System;
using System.Diagnostics;
using System.Text;
using System.Text.Json;
using YoutubeExplode;

namespace ReadVideo.Services.YoutubeManagement
{
    public class YoutubeSubtitleService : IYoutubeSubtitleService
    {
        public async Task<string> ExtractSubtitle(string videoId, string language, bool returnFullData)
        {
            try
            {

                // Create a new instance of YoutubeClient
                var youtube = new YoutubeClient();

                // Get the available subtitle tracks
                var tracks = await youtube.Videos.ClosedCaptions.GetManifestAsync(videoId);

                if (String.IsNullOrEmpty(language)) language = tracks.Tracks[0].Language.Code;

                // Select a track
                var trackInfo = tracks.GetByLanguage(language);//;?.WithAutoGenerated(false);

                if (trackInfo != null)
                {
                    // Get the actual subtitle track
                    var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

                    if (returnFullData)
                    {
                        // Assuming 'track.Captions' is a collection of some type that has 'Text' and 'Offset' properties
                        var fullChunks = track.Captions
                            .Where(caption => !string.IsNullOrEmpty(caption.Text.Trim()))
                            .Select(caption => caption)//new { Text = caption.Text, Offset = caption.Offset, Parts = caption.Parts,Duration = caption.Duration }) // Using anonymous type here
                            .ToList();

                        // Convert the list of anonymous types to a JSON string
                        return JsonSerializer.Serialize(fullChunks, new JsonSerializerOptions
                        {
                            WriteIndented = true // Optional: makes the JSON string more readable
                        });
                    }

                    List<SubtitleChunk> chunks = track.Captions.Where(caption => !String.IsNullOrEmpty(caption.Text.Trim())).Select(caption => new SubtitleChunk { Text = caption.Text, Offset = caption.Offset }).ToList();

                    // Convert the list of StructureB to a JSON string
                    return JsonSerializer.Serialize(chunks, new JsonSerializerOptions
                    {
                        WriteIndented = true // Optional: makes the JSON string more readable
                    });

                }

                return "";
            }
            catch (Exception)
            {

                throw;
            }

        }

        public async Task<string> ExtractSubtitleAsTextBlocks(string videoId, string language, int sentenceMinTimeSpan)
        {
            try
            {

                // Create a new instance of YoutubeClient
                var youtube = new YoutubeClient();

                // Get the available subtitle tracks
                var tracks = await youtube.Videos.ClosedCaptions.GetManifestAsync(videoId);

                if (String.IsNullOrEmpty(language)) language = tracks.Tracks[0].Language.Code;

                // Select a track
                var trackInfo = tracks.GetByLanguage(language);//;?.WithAutoGenerated(false);

                if (trackInfo != null)
                {
                    // Get the actual subtitle track
                    var track = await youtube.Videos.ClosedCaptions.GetAsync(trackInfo);

                    var fullChunks = track.Captions
                        .Where(caption => !string.IsNullOrEmpty(caption.Text.Trim()))
                        .ToList();

                    List<string> blocks = new List<string>();
                    StringBuilder newBlockBuilder = new StringBuilder();
                    for (int i = 0; i < fullChunks.Count; i++)
                    {
                        
                        for (int j = 0; j < fullChunks[i].Parts.Count; j++)
                        {
                            newBlockBuilder.Append(fullChunks[i].Parts[j]);
                            if (j < fullChunks[i].Parts.Count-1)
                            {
                                double msDifference = (fullChunks[i].Parts[j + 1].Offset - fullChunks[i].Parts[j].Offset).TotalMilliseconds;
                                if (msDifference> sentenceMinTimeSpan)
                                {
                                    blocks.Add(newBlockBuilder.ToString());
                                    newBlockBuilder.Clear();
                                }
                            }
                        }
                        
                    }

                    LinkedList<string> resultBlocks = new LinkedList<string>();
                    newBlockBuilder.Clear();
                    
                    for (int i = blocks.Count-1; i >= 0; i--)
                    {
                        if(newBlockBuilder.Length == 0)
                        {
                            newBlockBuilder.Append(blocks[i]);
                        }
                        else
                        {
                            if (CountWords(blocks[i].Trim()) <= 10)
                            {
                                newBlockBuilder.Insert(0,$"{blocks[i]} ");
                            }
                            else
                            {
                                resultBlocks.AddFirst(newBlockBuilder.ToString());
                                newBlockBuilder.Clear();
                                newBlockBuilder.Append(blocks[i]);
                            }
                        }

                    }
                    if (newBlockBuilder.Length > 0)
                    {
                        resultBlocks.AddFirst(newBlockBuilder.ToString());
                    }

                    // Convert the list of anonymous types to a JSON string
                    return JsonSerializer.Serialize(resultBlocks, new JsonSerializerOptions
                    {
                        WriteIndented = true // Optional: makes the JSON string more readable
                    });


                }

                return "";
            }
            catch (Exception)
            {

                throw;
            }

        }

        public int CountWords(string sentence)
        {
            if (string.IsNullOrWhiteSpace(sentence))
            {
                return 0; // Returns 0 if the sentence is null, empty, or consists only of white-space characters.
            }

            // Split the sentence by spaces and count the number of elements in the resulting array.
            // This uses the StringSplitOptions.RemoveEmptyEntries option to exclude any empty entries
            // that can occur if there are multiple spaces between words.
            return sentence.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries).Length;
        }

    }

    internal class SubtitleChunk
    {
        public string Text { get; set; }
        public TimeSpan Offset { get; set; }
    }
}
